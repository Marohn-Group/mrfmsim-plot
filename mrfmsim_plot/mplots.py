import numpy as np
from mayavi import mlab
from tvtk.api import tvtk
from functools import partial


def mayavi_imagedata(dataset, grid, name="data"):
    """Create a tvtk ImageData object from the dataset and grid for mlab.

    :param np.array dataset: the data to plot
    :param Grid grid: the grid object that contains step, origin, shape, and extents.
        "extents" is a list or nested list of the min and max of the grid
        in x, y, z direction
    :param str name: the name of the data
    """

    image_data = tvtk.ImageData(spacing=grid.step, origin=grid.origin)
    image_data.point_data.scalars = dataset.ravel()
    image_data.point_data.scalars.name = name
    image_data.dimensions = grid.shape
    image_data.extent = grid.extents.ravel()

    return image_data


def mayavi_generate_scene(image_data, method, size=(600, 600), **kwargs):

    name = image_data.point_data.scalars.name
    mlab.figure(name, size=size)
    getattr(mlab.pipeline, method)(image_data, **kwargs)
    mlab.outline()
    mlab.axes()
    mlab.colorbar(title=name, orientation="vertical")
    return mlab


def mayavi_plot(image_data, method, size=(600, 600), filename=None, **kwargs):

    mlab_obj = mayavi_generate_scene(image_data, method, size, **kwargs)

    if filename:
        mlab_obj.options.offscreen = True
        mlab_obj.savefig(filename)
        mlab_obj.close()

    else:
        mlab_obj.options.offscreen = False
        mlab_obj.show()


def mayavi_image_plane(image_data, size=(600, 600), filename=None, **kwargs):

    name = image_data.point_data.scalars.name
    mlab.figure(name, size=size)
    for i, orientation in enumerate(["x_axes", "y_axes", "z_axes"]):
        mlab.pipeline.image_plane_widget(
            image_data,
            plane_orientation=orientation,
            slice_index=image_data.dimensions[i] / 2,
            **kwargs
        )
    mlab.outline()
    mlab.axes()
    mlab.colorbar(title=name, orientation="vertical")
    mlab.show()


# def image_plane_widget_xyz(image_data, **kwargs):

#     for i, orientation in enumerate(["x_axes", "y_axes", "z_axes"]):
#         mlab.pipeline.image_plane_widget(
#             mlab_obj,
#             plane_orientation=orientation,
#             slice_index=image_data.dimensions[i] / 2,
#         )
# # def mayavi_save(image_data, method, filename, size=(600, 600), **kwargs):

# #     mlab_obj = mayavi_generate_scene(image_data, method, size, **kwargs)
# #     mlab_obj.savefig(filename)
# #     mlab_obj.close()

# def mayavi_image_plane(image_data, size=(600, 600), filename=None, **kwargs):

#     name = image_data.point_data.scalars.name
#     mlab.figure(name, size=size)
#         for i, orientation in enumerate(["x_axes", "y_axes", "z_axes"]):
#             mlab.pipeline.image_plane_widget(
#                 mlab_obj,
#                 plane_orientation=orientation,
#                 slice_index=image_data.dimensions[i] / 2,
#             )
#         mlab.outline()
#         mlab.axes()
#         mlab.colorbar(orientation="vertical")

#         return mlab_obj

# def image_plane(dataset, grid, colormap=None, *args, **kwargs):
#     """Plot the data in the grid with sliding planes widgets in x, y, z directions.

#     The x, y, z grid used needs to be full-sized grid, meaning x, y, z and
#     dataset have the same dimensions and shape.

#     :param np.array/list grid_array: full grid in x,y,z direction
#         This can be generated by np.mgrid, or np.broadcast_arrays of
#         appropriate shape. For mrfmsim, use ``grid.full_array``.
#     :param np.array dataset: data to image
#     :param string title: the title of the image
#     """

#     extent = grid.extents.ravel()
#     grid_array_full = np.broadcast_arrays(*grid.grid_array)

#     mlab.figure(size=(600, 600))
#     vtk_dataset = mlab.pipeline.scalar_field(*grid_array_full, dataset)
#     for i, orientation in enumerate(["x_axes", "y_axes", "z_axes"]):
#         mlab.pipeline.image_plane_widget(
#             vtk_dataset,
#             plane_orientation=orientation,
#             slice_index=grid.shape[i] / 2,
#             colormap=colormap or "jet",
#         )
#     mlab.outline()
#     mlab.axes(extent=extent)
#     mlab.colorbar(orientation="vertical")

#     return mlab
